---
layout: post
title:  "선택정렬 (sort쓰지 않고 정렬하기, 구조분해할당)"
categories: algo
comments: true
---

<br>

<br>

N개이 숫자가 입력되면 오름차순으로 정렬하여 출력하는 프로그램을 *작성하세요*. *정렬하는* 방법은 선택정렬입니다.

▣ 입력설명

첫 번째 줄에 자연수 *N*(1*<=**N**<=*100)이 주어집니다.

두 번째 줄에 N개의 자연수가 공백을 사이에 두고 *입력됩니다*. *각* 자연수는 정수형 범위 안에 있습니다.

▣ 출력설명

오름차순으로 정렬된 수열을 출력합니다.

▣ 입력예제 1

6

13 5 11 7 23 15

▣ 출력예제 1

5 7 11 13 15 23

<br>

<br>

<br>

<개념 & 문제 풀이법 생각>

정렬 문제는 sort를 사용해서 하면 된다. 나도 문제를 보고 sort로 풀었는데,

sort를 사용하지 않고 정렬을 하는 방법을 생각해보는 문제였다. 

idx를 찾아서 가장 최솟값을 구해서 순서를 교체해주면 되는데, 교체를 해주는 방법을 구조분해할당을 이용해서 해주었다.

<br>

<br>

2중for문을 이용해서 인덱스와 arr의 값을 비교해야하는 문제인데,

arr에 13, 5, 11, 7, 23, 15이라는 값이 있고 이 인덱스가 0,1,2,3,4,5 라면, 

0번 자리에는 누가 들어오는게 가장 작을지 한바퀴 다 돌고 최솟값을 넣고,

1번 자리에는 누가 들어오는게 가장 작을지 한바퀴 다 돌고 최솟값을 넣어주는 식으로 돌린다.



그럼 현재 주어진 인풋값으로 예를 든다면 `arr[j]`는 5이고  `arr[i]` 는 13이니까 `arr[j]` 가 더 크고 

그래서 `arr[j]` 와 `arr[idx]` 를 비교해서 `arr[j]` 값이 `arr[idx]` 보다 크면 두개의 값을 교체 해주면 된다.

<br>

<br>


---

# CASE 1

~~~js
function solution(arr){
    let answer=arr;
    for(let i=0; i<arr.length; i++){
        let idx=i;	//0부터시작. 가장 작은 칸부터 시작하자.
        for(let j=i+1; j<arr.length; j++){	//
            if(arr[j] < arr[idx]) idx=j;	//배열의 가장 앞(=arr[idx])의 값이 for문을 도는중 마주한 값보다 크다면 idx와 j를 교체.
        }
        [arr[i], arr[idx]] = [arr[idx], arr[i]];	//구조분해할당
    } 
    return answer;
}

let arr=[13, 5, 11, 7, 23, 15];
console.log(solution(arr));
~~~

---

<br>

`[arr[i], arr[idx]] = [arr[idx], arr[i]];` 이게 구조분해할당인데,

구조분해할당을 중괄호로 변수를 가져오는것만 해봤는데 대괄호도 가능해서 '오 이렇게 사용할수도 있군' 했던 문제.

수업에서 개념이름에 대해서는 설명을 안해주시고 'js에서 새로운 기능으로 이게 가능하죠~?' 라고만 말씀해주셔서

내가 따로 찾아본거긴한데.. 맞겠지? 

<br>

구조분해할당은 rest parameter와도 연결되는 개념인데(대괄호에도 쓰이는지 첨 알음!)

~~~js
let [ a, b, ...rest ] = [ 1, 2, 3, 4 ];

console.log(a);	// 1
console.log(b);	// 2
console.log(...rest);	// 3, 4
~~~

이렇게 배열이 선언되어있다면, a는 1이 되고, b는 2가 된다.

~~~js
let [ a = 4, b = 5, c = 6 ] = [ 1, 2 ];
console.log(a);	// 1
console.log(b);	// 2
console.log(c);	// 6
~~~

이렇게 배열이 선언되어있다면, a는 4라고 하더라도 1로 재할당되고, b도 마찬가지로 2가 되고, c는 할당받은게 없어서 그대로 6이다.

<br>

<br>

<br>

객체는 배열과는 조금 다른데, 객체는 키, 값의 형태이므로 키가 똑같아야 한다.

~~~js
let { a } = { a:40, b:60 };
console.log(a);	// 40;
~~~

<br>

아니 근데 쓰다보니까 구조분해할당 진짜 엄청 중요하네....?

이건 아예 따로 빼서 정리를 한번 해봐야겠다....

와우 이렇게 중요한 개념인지 몰랐는데 Nest.js에서 쓰는 문법구조에서 구조분해할당인게 진짜 엄청 많네......!! ༎ຶ‿༎ຶ

<br>

<br>

<br>

출처 :  [자바스크립트 알고리즘 문제풀이 입문(코딩테스트 대비)](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/dashboard)를 보고 작성!

